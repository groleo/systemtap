set test "utf_user_trunc"
set ::result_string {utf-16:012345678Z
utf-16:0123456789
utf-16:01234567Î©
utf-16:012345678
utf-16:0123456789
utf-16:0123456â˜º
utf-16:01234567
utf-16:012345678
utf-16:0123456789
utf-16:012345ðŸ˜ˆ
utf-16:0123456
utf-16:01234567
utf-16:012345678
utf-16:0123456789
utf-32:012345678Z
utf-32:0123456789
utf-32:01234567Î©
utf-32:012345678
utf-32:0123456789
utf-32:0123456â˜º
utf-32:01234567
utf-32:012345678
utf-32:0123456789
utf-32:012345ðŸ˜ˆ
utf-32:0123456
utf-32:01234567
utf-32:012345678
utf-32:0123456789}

set srcfile "$srcdir/$subdir/$test.c"
set stpfile "$srcdir/$subdir/$test.stp"
set exefile "[pwd]/$test.exe"
set test_flags "additional_flags=-g additional_flags=-DMAXSTRINGLEN=11"
set res [target_compile "$srcfile" "$exefile" executable "$test_flags"]
if { $res != "" } {
  verbose "target_compile failed: $res" 2
  fail "$test compile"
  untested "$test"
  return
} else {
  pass "$test compile"
}

foreach runtime [get_runtime_list] {
  if {$runtime != ""} {
    stap_run3 "$test ($runtime)" "$stpfile" -c "$exefile" \
      -DMAXSTRINGLEN=11 --runtime=$runtime
  } else {
    stap_run3 $test "$stpfile" -c "$exefile" -DMAXSTRINGLEN=11
  }
}
if { $verbose == 0 } { catch { exec rm -f $exefile } }
